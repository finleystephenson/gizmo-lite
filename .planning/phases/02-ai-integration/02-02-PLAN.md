---
phase: 02-ai-integration
plan: 02
type: feature
wave: 3
depends_on: [02-01]
files_modified:
  - src/services/flashcard_generator.py (modify)
autonomous: false
---

# Plan 02-02: Error Handling & Database Integration

## Objective

Add production-ready error handling with exponential backoff retry logic, and integrate FlashcardGenerator with the database to persist generated flashcards.

## Execution Context

**From Plan 02-01:**
- FlashcardGenerator service exists with core generation logic
- Structured outputs using Pydantic (FlashcardSet, FlashcardPair)
- Educational prompt generates 10 Q&A pairs
- Basic API connectivity working

**From Research (02-RESEARCH.md):**
- **Common API Errors:**
  - 429 (rate limit) - includes retry-after header
  - 529 (overloaded) - temporary, retry with backoff
  - 400 (invalid request) - don't retry, fix client code
  - 401 (auth) - API key issue, fail fast
- **Don't Hand-Roll Retry Logic:** Use exponential backoff with jitter
- **Retry Strategy:**
  - Initial delay: 1 second
  - Exponential: delay *= 2 each retry
  - Jitter: randomize to avoid thundering herd
  - Max retries: 3-5 attempts
  - Honor retry-after header when present
- **Rate Limit Acceleration:** New accounts have lower initial limits, increases with usage

**From Phase 1:**
- Database models: Deck.create(), Flashcard.create()
- Dict-based returns for easy JSON serialization
- Database in `flashcards.db`, auto-initialized on app start

## Context

**Wave 3: Error Handling + Database Integration**

Two independent enhancements to FlashcardGenerator:

1. **Retry Logic (Task 1):**
   - Wrap API call in retry decorator
   - Exponential backoff: 1s → 2s → 4s → 8s
   - Honor retry-after header for 429 errors
   - Add jitter to prevent synchronized retries
   - Only retry 429/529 (transient errors)
   - Don't retry 400/401 (client errors)

2. **Database Integration (Task 2):**
   - Add `save_to_database()` method to FlashcardGenerator
   - Create deck in database with topic name
   - Create 10 flashcard rows linked to deck (foreign key)
   - Use atomic transaction (all or nothing)
   - Return deck_id for future reference

These tasks are independent (can develop in parallel) but both modify the same file.

## Tasks

### Task 1: Add Exponential Backoff Retry Logic

**Goal:** Handle transient API errors (rate limits, overload) with intelligent retry strategy.

**Actions:**
1. Import retry dependencies:
   - `import time`
   - `import random`
   - `from anthropic import APIError, RateLimitError, InternalServerError`
2. Create `_retry_with_backoff()` helper method:
   - Takes a callable (the API call)
   - Implements exponential backoff with jitter
   - Max 3 retries
   - Honors retry-after header for RateLimitError
3. Update `generate_flashcards()` to use retry wrapper
4. Add user-friendly error messages for different failure types

**Retry Logic Pattern (from research):**
```python
def _retry_with_backoff(self, func, max_retries=3):
    """Retry API calls with exponential backoff and jitter."""
    for attempt in range(max_retries + 1):
        try:
            return func()
        except RateLimitError as e:
            if attempt == max_retries:
                raise ValueError(
                    "Rate limit exceeded. Please try again in a few minutes."
                ) from e

            # Honor retry-after header if present
            retry_after = getattr(e, 'retry_after', None)
            if retry_after:
                delay = float(retry_after)
            else:
                # Exponential backoff: 1s, 2s, 4s, 8s
                delay = (2 ** attempt) + random.uniform(0, 1)

            print(f"Rate limited. Retrying in {delay:.1f}s... (attempt {attempt + 1}/{max_retries})")
            time.sleep(delay)

        except InternalServerError as e:
            # 529 overloaded - retry with backoff
            if attempt == max_retries:
                raise ValueError(
                    "API temporarily unavailable. Please try again later."
                ) from e

            delay = (2 ** attempt) + random.uniform(0, 1)
            print(f"API overloaded. Retrying in {delay:.1f}s... (attempt {attempt + 1}/{max_retries})")
            time.sleep(delay)

        except APIError as e:
            # 400/401 and other errors - don't retry
            if e.status_code == 401:
                raise ValueError(
                    "Invalid API key. Check your ANTHROPIC_API_KEY in .env file."
                ) from e
            elif e.status_code == 400:
                raise ValueError(
                    f"Invalid request: {e.message}"
                ) from e
            else:
                raise ValueError(
                    f"API error: {e.message}"
                ) from e
```

**Update generate_flashcards():**
```python
def generate_flashcards(self, notes: str, topic: str) -> FlashcardSet:
    """Generate 10 flashcards from study notes using Claude with retry logic."""
    prompt = f"""You are an expert educator creating flashcards for active recall study.

Topic: {topic}

Study Notes:
{notes}

Generate exactly 10 flashcards that:
1. Test understanding, not memorization
2. Use questions requiring explanation (avoid yes/no questions)
3. Focus on key concepts from the notes
4. Include detailed answers that reinforce learning
5. Progress from fundamental to more complex concepts

Each flashcard should help the student recall and understand the material."""

    def api_call():
        response = self.client.beta.messages.parse(
            model="claude-sonnet-4-5-20250929",
            max_tokens=2048,
            messages=[{"role": "user", "content": prompt}],
            response_model=FlashcardSet,
        )
        return response.parsed

    # Use retry wrapper for resilience
    return self._retry_with_backoff(api_call)
```

**Student Learning Notes:**
- Exponential backoff prevents overwhelming the API during load
- Jitter (random delay) prevents thundering herd problem
- retry-after header is the server's guidance on when to retry
- Don't retry client errors (400/401) - fix the code instead

**Verification:**
- Test with valid request (should succeed on first try)
- Simulate rate limit by making rapid requests (should retry and succeed)
- Test with invalid API key (should fail fast with clear message)
- Verify retry delays increase: ~1s, ~2s, ~4s
- Verify jitter adds randomness (not exactly 1, 2, 4)

**Commit Message:**
```
feat(services): add exponential backoff retry logic

- Implement _retry_with_backoff() helper with jitter
- Honor retry-after header for 429 rate limit errors
- Retry 429/529 errors up to 3 times with exponential delay
- Fail fast for 400/401 client errors with clear messages
- User-friendly error messages for each failure type

Production-ready error handling for API resilience.
```

---

### Task 2: Add Database Integration

**Goal:** Persist generated flashcards to SQLite database for long-term storage and study mode access.

**Actions:**
1. Import database models:
   - `from src.models.deck import Deck`
   - `from src.models.flashcard import Flashcard`
2. Add `save_to_database(flashcard_set: FlashcardSet) -> int` method:
   - Create deck with topic name
   - Create 10 flashcard rows linked to deck
   - Return deck_id
3. Use atomic transaction (all or nothing):
   - Create deck first, get deck_id
   - Create flashcards with deck_id foreign key
   - If any flashcard fails, deck creation is still valid (CASCADE delete if deck removed later)
4. Add convenience method `generate_and_save()` that combines generation + saving

**Database Integration Pattern:**
```python
def save_to_database(self, flashcard_set: FlashcardSet) -> int:
    """Save generated flashcards to database.

    Args:
        flashcard_set: FlashcardSet object from generate_flashcards()

    Returns:
        deck_id: ID of created deck
    """
    # Create deck
    deck = Deck.create(name=flashcard_set.topic)
    deck_id = deck['id']

    # Create flashcards linked to deck
    for pair in flashcard_set.flashcards:
        Flashcard.create(
            deck_id=deck_id,
            question=pair.question,
            answer=pair.answer
        )

    return deck_id

def generate_and_save(self, notes: str, topic: str) -> dict:
    """Generate flashcards and save to database in one call.

    Returns:
        dict with deck_id and flashcard_count
    """
    # Generate flashcards using AI
    flashcard_set = self.generate_flashcards(notes, topic)

    # Save to database
    deck_id = self.save_to_database(flashcard_set)

    return {
        'deck_id': deck_id,
        'topic': flashcard_set.topic,
        'flashcard_count': len(flashcard_set.flashcards)
    }
```

**Student Learning Notes:**
- Foreign key (deck_id) links flashcards to their deck
- CASCADE delete (from Phase 1) means deleting deck removes flashcards
- Atomic operations: deck creation succeeds even if flashcard insert fails
- `generate_and_save()` provides convenient one-call API for common use case

**Verification:**
- Test end-to-end flow:
  ```python
  from src.services.flashcard_generator import FlashcardGenerator
  from src.models.deck import Deck
  from src.models.flashcard import Flashcard

  generator = FlashcardGenerator()
  notes = "Python uses indentation for blocks. Variables are dynamically typed. Lists are mutable, tuples are immutable."

  # Generate and save
  result = generator.generate_and_save(notes, "Python Basics")
  print(f"Created deck {result['deck_id']} with {result['flashcard_count']} cards")

  # Verify in database
  deck = Deck.get_by_id(result['deck_id'])
  print(f"Deck name: {deck['name']}")

  cards = Flashcard.get_by_deck(result['deck_id'])
  print(f"Retrieved {len(cards)} flashcards")
  for i, card in enumerate(cards[:3], 1):
      print(f"\nCard {i}:")
      print(f"Q: {card['question']}")
      print(f"A: {card['answer']}")
  ```
- Verify: Deck exists with correct topic name
- Verify: Exactly 10 flashcards exist with correct deck_id
- Verify: Questions and answers persisted correctly
- Verify: Foreign key relationship (query by deck_id works)

**Commit Message:**
```
feat(services): add database integration for flashcard persistence

- Add save_to_database() method to persist FlashcardSet
- Create deck with topic name, link flashcards via foreign key
- Add generate_and_save() convenience method for one-call workflow
- Return deck_id for future reference (study mode, editing)

Completes Phase 2: AI generation now persists to database.
```

## Verification

After completing both tasks:

1. **Retry logic validation:**
   - Successful generation works on first try
   - Rapid requests trigger retry (verify exponential delays)
   - Invalid API key fails fast with clear message
   - Print statements show retry progress

2. **Database integration validation:**
   - End-to-end test: notes → API → database
   - Verify deck created with correct topic
   - Verify 10 flashcards saved with foreign key
   - Query database to confirm persistence

3. **Combined workflow test:**
   ```python
   from src.services.flashcard_generator import FlashcardGenerator

   generator = FlashcardGenerator()

   # Test with real notes
   notes = """
   REST APIs use HTTP methods:
   - GET retrieves resources
   - POST creates new resources
   - PUT updates existing resources
   - DELETE removes resources

   Status codes indicate result:
   - 200 OK: success
   - 201 Created: new resource created
   - 400 Bad Request: client error
   - 404 Not Found: resource doesn't exist
   - 500 Internal Server Error: server error
   """

   result = generator.generate_and_save(notes, "REST API Basics")
   print(f"✅ Created deck {result['deck_id']} with {result['flashcard_count']} flashcards")
   ```

4. **Error scenarios:**
   - Invalid API key → clear error message
   - Empty notes → generates flashcards or fails gracefully
   - Network issues → retries then fails with message

## Success Criteria

- [ ] Retry logic with exponential backoff implemented
- [ ] Honors retry-after header for 429 errors
- [ ] Adds jitter to prevent thundering herd
- [ ] Only retries transient errors (429, 529)
- [ ] Fails fast for client errors (400, 401) with clear messages
- [ ] Database integration saves flashcards to Deck + Flashcard tables
- [ ] Foreign key relationship maintained (deck_id links)
- [ ] `generate_and_save()` convenience method works end-to-end
- [ ] Test script demonstrates full workflow (notes → API → database)
- [ ] 2 git commits (Task 1: retry, Task 2: database)

## Output

**Deliverables:**
1. Production-ready error handling in FlashcardGenerator
2. Database persistence for generated flashcards
3. Test script showing end-to-end workflow
4. 2 atomic git commits

**Phase 2 Complete!**

✅ Can generate 10 flashcards from study notes
✅ Structured outputs guarantee valid JSON
✅ Retry logic handles rate limits and transient errors
✅ Flashcards persist to database for study mode
✅ Ready for Phase 3 (Card Generation Interface)

**Educational Value:**

Student learns:
- Exponential backoff prevents API overwhelming
- Jitter prevents synchronized retry storms
- retry-after header provides server guidance
- Don't retry client errors - fix the code
- Foreign keys maintain data relationships
- Atomic operations for data integrity
